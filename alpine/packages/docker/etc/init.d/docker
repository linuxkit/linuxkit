#!/sbin/openrc-run

depend()
{
	after transfused
	before chronyd
}

start()
{
	ebegin "Starting Docker"

	# shift logs onto host before docker starts
	# try to keep initial log files, although there is a race
	# busybox reopens its log files every second
	if cat /proc/cmdline | grep -q 'com.docker.driverDir'
	then
		DRIVERDIR="/Mac$(cat /proc/cmdline | sed -e 's/.*com.docker.driverDir="//' -e 's/".*//')"
		rm -rf /var/tmp/log
		mkdir -p /var/tmp/log
		for f in /var/log/*
		do
			cp -a $f /var/tmp/log/$(basename $f)
		done
		mount --bind "${DRIVERDIR}/log" /var/log
		for f in /var/tmp/log/*
		do
			[ -f $f ] && cat $f >> /var/log/$(basename $f)
		done
		rm -rf /var/tmp/log
	fi

	command="${DOCKER_BINARY:-/usr/bin/docker}"

	pidfile="/run/docker.pid"

	# Start with networking on both Mac and Hyper-V, but in
	# future change this to use a hypervisor socket.
	DOCKER_OPTS="${DOCKER_OPTS} -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock"

	if mobyconfig exists etc/docker
	then
		cp -a $(mobyconfig find etc/docker) /etc/docker/
	fi
	if mobyconfig exists network
	then
		NETWORK_MODE="$(mobyconfig get network | tr -d '[[:space:]]')"
		NATIVE_PORT_FORWARDING="$(mobyconfig get native/port-forwarding | tr -d '[[:space:]]')"
		if [ "${NETWORK_MODE}" = "slirp" -o "${NATIVE_PORT_FORWARDING}" = "true" ]; then
			DOCKER_OPTS="${DOCKER_OPTS} --userland-proxy-bin /sbin/proxy"
		fi
	fi
	if mobyconfig exists insecure-registry
	then
		DOCKER_OPTS="${DOCKER_OPTS} --insecure-registry $(mobyconfig get insecure-registry)"
	fi

	for d in Users Volumes tmp private
	do
		[ -d /Mac/$d ] && mkdir -p /$d && mount --bind /Mac/$d /$d
	done

	# same default ulimit as boot2docker; if you want more can set at docker run time
	DOCKER_ULIMITS=1048576
	ulimit -n $DOCKER_ULIMITS
	ulimit -p $DOCKER_ULIMITS

	DOCKER_LOGFILE="/var/log/docker.log"

	start-stop-daemon --start --quiet \
		--background \
		--exec ${command} \
		--pidfile ${pidfile} \
		--stderr "${DOCKER_LOGFILE}" \
		--stdout "${DOCKER_LOGFILE}" \
		-- daemon --pidfile=${pidfile} ${DOCKER_OPTS}

	eend $? "Failed to start docker"
}

stop()
{
	# stop docker
	einfo "Stopping docker"
	pidfile="/run/docker.pid"
	start-stop-daemon --stop --quiet --pidfile ${pidfile}

	# taken from localmount stop script
	# XXX fix more cleanly see #35

        yesno $RC_GOINGDOWN || return 0
        # We never unmount / or /dev or $RC_SVCDIR

        # Bug 381783
        local rc_svcdir=$(printf '%s\n' "$RC_SVCDIR" | sed 's:/lib\(32\|64\)\?/:/lib(32|64)?/:g')

        local x= no_umounts_r="/|/dev|/dev/.*|${rc_svcdir}"
        no_umounts_r="${no_umounts_r}|/bin|/sbin|/lib(32|64)?|/libexec"
        # RC_NO_UMOUNTS is an env var that can be set by plugins
        local IFS="$IFS:"
        for x in $no_umounts $RC_NO_UMOUNTS; do
                no_umounts_r="$no_umounts_r|$x"
        done

        if [ "$RC_UNAME" = Linux ]; then
                no_umounts_r="$no_umounts_r|/proc|/proc/.*|/run|/sys|/sys/.*"
                if [ -e "$rc_svcdir"/usr_premounted ]; then
                        no_umounts_r="$no_umounts_r|/usr"
                fi
        fi
        no_umounts_r="^($no_umounts_r)$"

        # Flush all pending disk writes now
        sync

        . "$RC_LIBEXECDIR"/sh/rc-mount.sh

        if [ "$RC_UNAME" = Linux ] && [ -d /sys/fs/aufs ] ; then
                #if / is aufs we remount it noxino during shutdown
                if mountinfo -q -f '^aufs$' / ; then
                        mount -o remount,noxino,rw /
                        sync
                fi

                local aufs_branch aufs_mount_point aufs_si_id aufs_br_id branches
                for aufs_si_dir in /sys/fs/aufs/si*; do
                        [ -d "${aufs_si_dir}" ] || continue
                        aufs_si_id="si=${aufs_si_dir#/sys/fs/aufs/si_}"
                        aufs_mount_point="$(mountinfo -o ${aufs_si_id})"
                        branches="$aufs_si_dir/br[0-9] $aufs_si_dir/br[0-9][0-9] $aufs_si_dir/br[0-9][0-9][0-9]"
                        for x in $branches; do
                                [ -e "${x}" ] || continue
                                aufs_branch=$(sed 's/=.*//g' $x)
                                eindent
                                if ! mount -o "remount,del:$aufs_branch" "$aufs_mount_point" > /dev/null 2>&1; then
                                        ewarn "Failed to remove branch $aufs_branch from aufs \
                                        $aufs_mount_point"
                                fi
                                eoutdent
                                sync
                        done
                done
        fi

        # Umount loop devices
        einfo "Unmounting loop devices"
        eindent
        do_unmount "umount -d" --skip-point-regex "$no_umounts_r" \
                --node-regex "^/dev/loop"
        eoutdent

        # Now everything else, except network filesystems as the
        # network should be down by this point.
        einfo "Unmounting filesystems"
        eindent
        local fs=
        for x in $net_fs_list $extra_net_fs_list; do
                fs="$fs${fs:+|}$x"
        done
        [ -n "$fs" ] && fs="^($fs)$"
        do_unmount umount --skip-point-regex "$no_umounts_r" \
                "${fs:+--skip-fstype-regex}" $fs --nonetdev
        eoutdent

	# now terminate with extreme prejudice
	halt -f

        return 0
}

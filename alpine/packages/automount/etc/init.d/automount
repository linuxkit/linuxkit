#!/sbin/openrc-run

depend()
{
	need dev
}

do_fsck()
{
	/sbin/e2fsck -p $*
	EXIT_CODE=$?
	# exit code 1 is errors corrected
	[ "${EXIT_CODE}" -eq 1 ] && EXIT_CODE=0
	# exit code 2 or 3 means need to reboot
	[ "${EXIT_CODE}" -eq 2 -o "${EXIT_CODE}" -eq 3 ] && /sbin/reboot
	# exit code 4 or over is fatal
	[ "${EXIT_CODE}" -ge 4 ] && printf "Filesystem unrecoverably corrupted, will reformat\n"
	return "${EXIT_CODE}"
}

do_fsck_extend_mount()
{
	DRIVE="$1"
	DATA="$2"

	do_fsck "$DATA" || return 1

	# only try to extend if there is a single partition and free space
	PARTITIONS=$(sfdisk -J "$DRIVE" | jq '.partitiontable.partitions | length')

	if [ "$PARTITIONS" -eq 1 ] && \
		sfdisk -F "$DRIVE" | grep -q 'Unpartitioned space' &&
		! sfdisk -F "$DRIVE" | grep -q '0 B, 0 bytes, 0 sectors'
	then
		SPACE=$(sfdisk -F "$DRIVE" | grep 'Unpartitioned space')
		printf "Resizing disk partition: $SPACE\n"

		START=$(sfdisk -J "$DRIVE" | jq -e '.partitiontable.partitions | map(select(.type=="83")) | .[0].start')

		sfdisk -q --delete "$DRIVE" 2> /dev/null
		echo "${START},,83;" | sfdisk -q "$DRIVE"

		# set bootable flag
		sfdisk -A "$DRIVE" 1

		# update status
		blockdev --rereadpt $diskdev 2> /dev/null
		mdev -s

		# resize2fs fails unless we use -f here
		do_fsck -f "$DATA" || return 1
		resize2fs "$DATA"

		do_fsck "$DATA" || return 1
	fi

	mount "$DATA" /var
}

do_mkfs()
{
	diskdev="$1"

	# new disks does not have an DOS signature in sector 0
	# this makes sfdisk complain. We can workaround this by letting
	# fdisk create that DOS signature, by just do a "w", a write.
	# http://bugs.alpinelinux.org/issues/145
	echo "w" | fdisk $diskdev >/dev/null

	# format one large partition
	echo ";" | sfdisk --quiet $diskdev

	# update status
	blockdev --rereadpt $diskdev 2> /dev/null
	mdev -s

	FSOPTS="-O resize_inode,has_journal,extent,huge_file,flex_bg,uninit_bg,64bit,dir_nlink,extra_isize"

	mkfs.ext4 -q -F $FSOPTS ${diskdev}1

	mount ${diskdev}1 /var
}

do_swapfile()
{
	DRIVE=$1
	SIZE=$(sfdisk -J "$DRIVE" | jq -e -r '.partitiontable.partitions | map(select(.type=="83")) | .[0].size')
	SWAP=/var/spool/swap
	MOUNT=$(mount | grep 'on /var type')
	# Create swap on desktop platforms if disk size larger than 16GB
	if [ "$(mobyplatform)" = "mac" -o "$(mobyplatform)" = "windows" ] && \
		[ ! -f $SWAP ] && [ "$SIZE" -gt 33554432 ] && \
		[ -n "$MOUNT" ]
	then
		mkdir -p "$(dirname $SWAP)"
		dd if=/dev/zero of=$SWAP bs=1k count=1048576
		chmod 600 $SWAP
		mkswap $SWAP
	fi
	[ -f "$SWAP" ] && swapon $SWAP
}

start()
{
	ebegin "Configuring host block device"

	# We are being specific with Azure for now.  Otherwise the subshell
	# below will reference /dev/sdb, which is Azure's "local resource disk"
	# (see
	# https://blogs.msdn.microsoft.com/mast/2013/12/06/understanding-the-temporary-drive-on-windows-azure-virtual-machines/).
	#
	# Since attempting to format swap on that disk will cause Azure VHD
	# validation to fail, we default to using /dev/sda.  requirements
	# including not allowing swap partitions.
	#
	# IMPORTANT: If this, or the root device (/dev/sda1) changes in the
	# syslinux / bootloader config for Azure, they will need to be updated
	# in parallel.
	if [ "$(mobyplatform)" = "azure" ]
	then
		DEV="sda"
	else
		DEV="$(find /dev -maxdepth 1 -type b ! -name 'loop*' | grep -v '[0-9]$' | sed 's@.*/dev/@@' | sort | head -1 )"
	fi

	[ -z "${DEV}" ] && exit 1

	DRIVE="/dev/${DEV}"

	# see if it has a partition table already
	if sfdisk -d "${DRIVE}" >/dev/null 2>/dev/null
	then
		DATA=$(sfdisk -J "$DRIVE" | jq -e -r '.partitiontable.partitions | map(select(.type=="83")) | .[0].node')
		if [ $? -eq 0 ]
		then
			do_fsck_extend_mount "$DRIVE" "$DATA" || do_mkfs "$DRIVE"
		else
			do_mkfs "$DRIVE"
		fi
	else
		do_mkfs "$DRIVE"
	fi

	# Use existing swap partition of present; we do not create one now
	SWAP=$(fdisk -l "$DRIVE" | grep 'Linux swap' | head -1 | awk '{print $1}')
	[ -z "$SWAP" ] && do_swapfile "$DRIVE" || swapon "$SWAP"

	# boot2docker compat, has /var and /tmp on partition
	[ -d /var/var/lib/boot2docker/ ] && (mv /var/var/* /var && rm -rf /var/var)

	# add in directories under /var that are lost in formatting
	[ -L /var/run ] || ln -s /run /var/run
	[ -L /var/lock ] || ln -s /run/lock /var/lock
	[ -d /var/log ] || mkdir -m 755 /var/log
	[ -d /var/empty ] || mkdir -m 755 /var/empty
	[ -d /var/spool ] || mkdir -m 755 /var/spool
	[ -d /var/cache ] || mkdir -m 755 /var/cache
	[ -d /var/cache/apk ] || mkdir -m 755 /var/cache/apk
	[ -d /var/cache/misc ] || mkdir -m 755 /var/cache/misc
	[ -d /var/local ] || mkdir -m 755 /var/local
	[ -d /var/tmp ] || mkdir -m 1777 /var/tmp

	mount | grep -q ' on /var type '

	eend $? "Failed to mount block device"
}
